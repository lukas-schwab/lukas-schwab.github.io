<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Which Concept is better?</title>
  <style>
    :root {
      --bg: #0f1724;
      --card: #0b1220;
      --accent: #7c3aed;
      --muted: #94a3b8
    }

    html,
    body {
      height: 100%
    }

    body {
      margin: 0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg, #071022 0%, #0b1220 100%);
      color: #e6eef8;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      box-sizing: border-box;
    }

    .app {
      width: min(1100px, 100%);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));
      border-radius: 14px;
      padding: 18px;
      box-shadow: 0 10px 30px rgba(2, 6, 23, 0.6)
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px
    }

    h1 {
      font-size: 18px;
      margin: 0
    }

    p.lead {
      margin: 0;
      color: var(--muted);
      font-size: 13px
    }

    .images {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px
    }

    .card {
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.01), rgba(255, 255, 255, 0.00));
      border-radius: 10px;
      padding: 10px;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      min-height: 360px;
      position: relative;
      cursor: pointer;
      transition: transform .15s ease, box-shadow .15s ease
    }

    .card:hover {
      transform: translateY(-6px);
      box-shadow: 0 10px 30px rgba(12, 18, 37, 0.45)
    }

    .card.selected {
      outline: 4px solid rgba(124, 58, 237, 0.12);
      box-shadow: 0 20px 40px rgba(124, 58, 237, 0.09);
      transform: translateY(-2px)
    }

    .imgwrap {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      border-radius: 8px;
      background: linear-gradient(180deg, #081226, #071226);
      /* Added transition for smoother image loading */
      transition: opacity 0.3s ease;
      opacity: 1;
    }

    /* Style for when images are loading */
    .imgwrap img[src=""] {
      opacity: 0;
    }

    .imgwrap img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      display: block;
      /* Add fallback color and min-height */
      background-color: #071226;
      min-height: 100px;
    }

    .meta {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-top: 10px
    }

    .count {
      font-size: 13px;
      color: var(--muted)
    }

    .controls {
      display: flex;
      gap: 8px
    }

    button {
      background: transparent;
      border: 1px solid rgba(255, 255, 255, 0.06);
      color: var(--muted);
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 13px;
      cursor: pointer
    }

    button.primary {
      background: linear-gradient(90deg, var(--accent), #5b21b6);
      border: none;
      color: white
    }

    .small {
      font-size: 12px;
      padding: 6px 8px
    }

    .urlinputs {
      display: flex;
      gap: 8px;
      margin-top: 12px
    }

    input[type=text] {
      flex: 1;
      padding: 8px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.04);
      background: transparent;
      color: inherit
    }

    .status {
      margin-top: 10px;
      color: var(--muted);
      font-size: 13px;
      min-height: 1.2em;
      /* Prevent layout shift */
    }

    footer {
      margin-top: 12px;
      color: var(--muted);
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: space-between
    }

    .overlay-count {
      position: absolute;
      left: 10px;
      top: 10px;
      background: rgba(2, 6, 23, 0.6);
      padding: 6px 8px;
      border-radius: 8px;
      font-size: 13px
    }

    .hint {
      font-size: 12px;
      color: var(--muted)
    }

    @media (max-width:760px) {
      .images {
        grid-template-columns: 1fr;
      }

      .card {
        min-height: 240px
      }
    }
  </style>
</head>

<body>
  <main class="app" role="main">
    <header>
      <div>
        <h1>Which concepts are more descriptive?</h1>
        <p class="lead">Click the concepts you think are better.</p>
      </div>
      <div class="controls">
        <!-- <label class="small" title="Upload two files"><input id="fileA" type="file" accept="image/*" style="display:none"/><input id="fileB" type="file" accept="image/*" style="display:none"/></label> -->
        <!-- <button id="uploadBtn" class="small">Upload images</button> -->
        <!-- <button id="swapBtn" class="small">Swap</button> -->
        <!-- <button id="resetBtn" class="small">Reset votes</button> -->
      </div>
    </header>

    <section class="images" id="images">
      <div class="card" id="cardA" tabindex="0" data-side="A">
        <!-- <div class="overlay-count" id="countA">0 votes</div> -->
        <div class="imgwrap"><img id="imgA" alt="Image A" src=""> <!-- Start empty, will be loaded by JS -->
        </div>
        <div class="meta">
          <div class="hint">Press ← or 1 to pick left</div>
          <div class="count" id="metaA">Left</div>
        </div>
      </div>

      <div class="card" id="cardB" tabindex="0" data-side="B">
        <!-- <div class="overlay-count" id="countB">0 votes</div> -->
        <div class="imgwrap"><img id="imgB" alt="Image B" src=""> <!-- Start empty, will be loaded by JS -->
        </div>
        <div class="meta">
          <div class="hint">Press → or 2 to pick right</div>
          <div class="count" id="metaB">Right</div>
        </div>
      </div>
    </section>

    <!-- <div class="urlinputs">
      <input id="urlA" type="text" placeholder="Image URL for left (or leave)" />
      <input id="urlB" type="text" placeholder="Image URL for right (or leave)" />
      <button id="loadUrls" class="primary small">Load URLs</button>
    </div> -->

    <div class="status" id="status"></div>

    <footer>
      <div>Tip: click an image or press 1 / 2 / ← / →. Images are identified by URL or file name for counting.</div>
      <div>Made with ❤️</div>
    </footer>
  </main>

  <script>
    // =============================================================================
    // STATE MANAGEMENT
    // =============================================================================

    const state = {
      currentPair: [null, null], // [imageA_url, imageB_url]
      imageUrlQueue: [], // Stores upcoming pairs [ [a1, b1], [a2, b2], ... ]
      session: null,
      isVoting: true,    // Start true to block voting until first images load
      isFetching: false, // Prevent simultaneous fetches
    };

    // =============================================================================
    // DOM ELEMENTS
    // =============================================================================

    const elements = {
      imgA: document.getElementById('imgA'),
      imgB: document.getElementById('imgB'),
      cardA: document.getElementById('cardA'),
      cardB: document.getElementById('cardB'),
      countAel: document.getElementById('countA'),
      countBel: document.getElementById('countB'),
      status: document.getElementById('status'),
      // urlA: document.getElementById('urlA'),
      // urlB: document.getElementById('urlB'),
      // loadUrls: document.getElementById('loadUrls'),
      // swapBtn: document.getElementById('swapBtn'),
      // resetBtn: document.getElementById('resetBtn'),
      // uploadBtn: document.getElementById('uploadBtn'),
    };

    // =============================================================================
    // BACKEND INTEGRATION
    // =============================================================================

    const BACKEND_URL = "https://script.google.com/macros/s/AKfycbz7SH8va_1Zy0TR7cJXL9-_FcunWEUtJOOwHdPRlNRx_yJsi4TieE6ujirK_o_TnBWCMQ/exec";
    const IMAGE_QUEUE_LOW_WATER_MARK = 2; // Fetch more images when queue has this many pairs left

    document.addEventListener('DOMContentLoaded', () => {
      init();
    });

    function getOrCreateSession() {
      if (!state.session) {
        state.session = localStorage.getItem("session") || (() => {
          const s = crypto.randomUUID();
          localStorage.setItem("session", s);
          return s;
        })();
      }
      return state.session;
    }

    /**
     * Submits the vote in the background without blocking the UI.
     */
    async function submitVoteInBackground(side, pair, imgSrcToCount) {
      console.log('Submitting vote...');

      try {
        const payload = {
          imageA: pair[0],
          imageB: pair[1],
          choice: side,
          session: getOrCreateSession()
        };

        const response = await fetch(BACKEND_URL, {
          method: "POST",
          mode: 'cors',
          headers: { "Content-Type": "text/plain;charset=utf-8" },
          body: JSON.stringify(payload),
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        console.log('Vote recorded!');
        // Update local counts after successful vote
        updateLocalVoteCount(imgSrcToCount);
        // updateDisplayedCounts(); // Counts are updated when new pair is shown

      } catch (error) {
        console.error('Vote submission failed:', error);
        updateStatus('Last vote failed to submit. It may be retried.');
      }
    }

    /**
     * Fetches a batch of image URLs (10) from the backend and adds them to the queue.
     */
    async function fetchImageBatch() {
      if (state.isFetching) return;
      state.isFetching = true;
      console.log('Fetching new image batch...');

      try {
        const response = await fetch(BACKEND_URL, {
          method: "GET",
          mode: 'cors',
          headers: { "Content-Type": "text/plain;charset=utf-8" }
        });

        if (!response.ok) throw new Error(`HTTP ${response.status}`);

        const responseText = await response.text();
        const data = JSON.parse(responseText);

        // Assuming data.received is an array of 10 URLs
        const pairs = [];
        if (data.received && data.received.length > 0) {
          for (let i = 0; i < data.received.length; i += 2) {
            if (data.received[i] && data.received[i + 1]) {
              pairs.push([data.received[i], data.received[i + 1]]);
            }
          }
        }

        if (pairs.length > 0) {
          state.imageUrlQueue.push(...pairs);
          console.log(`Added ${pairs.length} new pairs to queue.`);
        } else {
          throw new Error('No valid image pairs received from backend.');
        }

      } catch (error) {
        console.error('Loading URLs failed:', error);
        updateStatus('Loading new images failed, try reloading the site.');
      } finally {
        state.isFetching = false;
      }
    }

    // =============================================================================
    // LOCAL STORAGE MANAGEMENT
    // =============================================================================

    function storageGet() {
      try {
        return JSON.parse(localStorage.getItem('two-image-votes') || '{}');
      } catch (e) {
        return {};
      }
    }

    function storageSet(obj) {
      localStorage.setItem('two-image-votes', JSON.stringify(obj));
    }

    function idFor(src) {
      if (!src) return 'unknown';
      try {
        if (src.startsWith('data:')) return src.slice(0, 80);
        const u = new URL(src, location.href);
        return u.origin + u.pathname;
      } catch (e) {
        return src;
      }
    }

    /**
     * Updates the local vote count for a specific image source.
     */
    function updateLocalVoteCount(imgSrc) {
      const store = storageGet();
      const id = idFor(imgSrc);
      store[id] = (store[id] || 0) + 1;
      storageSet(store);
    }

    /**
     * Updates the displayed vote counts for the *currently visible* images.
     */
    function updateDisplayedCounts() {
      // This feature is currently commented out in the HTML.
      // If re-enabled, this function will work as intended.
      if (!elements.countAel || !elements.countBel) return;

      const store = storageGet();
      const countA = store[idFor(elements.imgA.src)] || 0;
      const countB = store[idFor(elements.imgB.src)] || 0;
      // elements.countAel.textContent = countA + ' votes';
      // elements.countBel.textContent = countB + ' votes';
    }

    // =============================================================================
    // UI HELPERS
    // =============================================================================

    function updateStatus(message) {
      elements.status.textContent = message;
    }

    /**
     * Gets the next pair from the queue and displays them.
     * Fetches more images if the queue is empty or low.
     */
    async function displayNextPair() {
      // 1. Check if queue is empty and fetch if needed
      if (state.imageUrlQueue.length === 0) {
        updateStatus('Fetching new images...');
        await fetchImageBatch(); // Wait for it to finish

        // After await, check again in case fetch failed
        if (state.imageUrlQueue.length === 0) {
          updateStatus('Failed to load new images. Please refresh.');
          state.isVoting = true; // Block voting
          return; // Can't proceed
        }
      }


      // 2. Queue has images, so display the next one
      const nextPair = state.imageUrlQueue.shift();
      state.currentPair = nextPair;

      // Set src to empty string first to trigger loading state (if CSS is set up)
      elements.imgA.src = "";
      elements.imgB.src = "";

      // Set the actual source
      elements.imgA.src = state.currentPair[0];
      elements.imgB.src = state.currentPair[1];

      updateDisplayedCounts(); // Update counts for the *new* pair
      updateStatus('Please vote.');
      state.isVoting = false; // Allow voting for this new pair

      // 3. Check buffer and pre-fetch if necessary
      if (state.imageUrlQueue.length <= IMAGE_QUEUE_LOW_WATER_MARK && !state.isFetching) {
        // Don't await, just start it in the background
        console.log('Queue is low, pre-fetching next batch...');
        fetchImageBatch();
      }
    }


    function addSelectedEffect(side) {
      // Remove previous selection
      elements.cardA.classList.remove('selected');
      elements.cardB.classList.remove('selected');

      // Add selection to voted card
      if (side === 'A') {
        elements.cardA.classList.add('selected');
      } else {
        elements.cardB.classList.add('selected');
      }

      // Remove selection after animation
      setTimeout(() => {
        elements.cardA.classList.remove('selected');
        elements.cardB.classList.remove('selected');
      }, 1000);
    }

    // =============================================================================
    // VOTING LOGIC
    // =============================================================================

    async function vote(side) {
      if (state.isVoting) return; // Prevent double-clicks
      state.isVoting = true; // Block *new* votes immediately

      // 1. Get data for the vote before changing images
      const pairToSubmit = [...state.currentPair];
      const imgSrcToCount = pairToSubmit[side === 'A' ? 0 : 1];

      // 2. Update UI immediately
      addSelectedEffect(side);

      // 3. Start background submission
      // We don't await this. It runs in parallel.
      submitVoteInBackground(side, pairToSubmit, imgSrcToCount);

      // 4. Load and display the next pair
      // This is awaited, and will set state.isVoting = false when done
      // For UX reasons we also wait before setting the new image.
      setTimeout(async () => {
        await displayNextPair();
      }, 750);
    }

    // =============================================================================
    // EVENT LISTENERS
    // =============================================================================

    function setupEventListeners() {
      // Vote handlers
      elements.cardA.addEventListener('click', () => vote('A'));
      elements.cardB.addEventListener('click', () => vote('B'));

      // Keyboard support
      window.addEventListener('keydown', (e) => {
        if (state.isVoting) return; // Ignore keypress if not ready
        if (e.key === 'ArrowLeft' || e.key === '1') vote('A');
        if (e.key === 'ArrowRight' || e.key === '2') vote('B');
      });

      // Reset votes (if button is re-enabled)
      // if (elements.resetBtn) {
      //   elements.resetBtn.addEventListener('click', () => {
      //     // Use a custom modal instead of confirm()
      //     updateStatus('Resetting votes... (feature in dev)');
      //     // localStorage.removeItem('two-image-votes');
      //     // updateDisplayedCounts();
      //     // updateStatus('Local votes reset.');
      //   });
      // }

      // Accessibility
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Tab') document.body.classList.add('show-focus');
      });
    }

    // =============================================================================
    // INITIALIZATION
    // =============================================================================

    function init() {
      setupEventListeners();
      getOrCreateSession(); // Ensure session is created
      updateStatus('Loading first images...');

      // Kick off the whole process
      displayNextPair();
    }

    // =============================================================================
    // DEBUG HELPERS
    // =============================================================================

    window.twoImageVote = {
      vote,
      updateDisplayedCounts,
      storageGet,
      state,
      elements,
      fetchImageBatch,
      displayNextPair
    };
  </script>
</body>

</html>